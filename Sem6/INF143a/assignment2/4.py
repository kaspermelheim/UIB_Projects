#4
import random
import math
#Consider the Elgamal digital signature scheme. Suppose during key generating we have selected:
p = 172471720944269739125606601541029487739340755626635772583971303759438419175772663669593721846550197442744469656080602946644927061951111688637275362803660140005841509436858417187894094969161813013831722315776185924842099093899593568334696592964516617033076246061593684511550344711963113062475271615663164060997
#and
g = 3

#Suppose the secret key is:
d = 333

#Compute the public key (p, g, β)

#Answer
#We already have p and q so we need to find β. 
#Formula: β  =  g^d mod p

def findβ():
    return (g**d)%p
    #return pow(g, d, p)
print("β: " + str(findβ()) + "\n")

#From the function above we find that:
β = 760988023132059809720425867265032780727896356372077865117010037035791631439306199613044145649378522557935351570949952010001833769302566531786879537190794573523

#We find the public key:
#(p,g,β) = (172471720944269739125606601541029487739340755626635772583971303759438419175772663669593721846550197442744469656080602946644927061951111688637275362803660140005841509436858417187894094969161813013831722315776185924842099093899593568334696592964516617033076246061593684511550344711963113062475271615663164060997, 3, 760988023132059809720425867265032780727896356372077865117010037035791631439306199613044145649378522557935351570949952010001833769302566531786879537190794573523)
public_key = (p,g,β)
print("Public key (p, g, β): " + str(public_key) + "\n")

#Consider the message x = A3F B8F CE (32 bits). Show how it can be represented as an integer modulo p.

#Answer:
x_before = "A3F B8F CE"
def convert(message):
    new = ""
    for chr in message:
        new += str(ord(chr) % p) 
    return new

#Print converted message
print("Message converted to integer modulo p: " + str(convert(x_before)) + "\n")

#We have now converted the message x to integer number: 65517032665670326769
x = 65517032665670326769

#Sign the message x, i.e. compute the signature (x,(r, s))

#Answer:

#Following step by step guide from lecture notes
#Sign message
def signMessage(p, g, d, x):

    #Pick an ephemeral key eph_key ∈ {1, 2, . . . , p − 2} with gcd(k, p − 1) == 1
    while True:
        eph_key = random.randint(1, p-2)
        if math.gcd(eph_key, p-1) == 1:
            break
    
    #Compute r = g^eph_key (mod p)
    r = pow(g, eph_key, p)

    #Compute s = (x − dr) * eph_key^-1 * (mod p − 1) 
    s = (x-d*r) * pow(eph_key, -1, p-1) % (p-1)

    #Return (r,s) pair
    return r,s

sign = signMessage(p, g, d, x)

r = sign[0]
s = sign[1]

#Print signature (x, (r,s))
print("Signature: (" + str(x) + ", " + str(sign)+ "\n")

#From this function we retrieve (randomized each time we run the program) (r,s): (11026863186369602222686353295278358896453814171864844488390619460932935922416770564434780804120423283449474349645362234373585329787676150033316735807553839197513772260226567607852121840189822342035075934791187848003343783390528807621112269827220233828343821345101742218846405598772734778958137698833652326541, 73327594856497919057066102895986653436771493540601020166908078287346985314283881571979457311093099221278925977837181521129302181310941027562535187932785316326435710590416758307718991487605412588141408263660342315160219092025747182743808127820697877545166525660580083746171614268764750985039028296768281042792)
#And we sign the message: (x,(r,s)) = (65517032665670326769, (11026863186369602222686353295278358896453814171864844488390619460932935922416770564434780804120423283449474349645362234373585329787676150033316735807553839197513772260226567607852121840189822342035075934791187848003343783390528807621112269827220233828343821345101742218846405598772734778958137698833652326541, 73327594856497919057066102895986653436771493540601020166908078287346985314283881571979457311093099221278925977837181521129302181310941027562535187932785316326435710590416758307718991487605412588141408263660342315160219092025747182743808127820697877545166525660580083746171614268764750985039028296768281042792))

#Show how the signature is verified

#Answer:

#Following step by step guide from lecture notes
#Verify the signature
def verifySignature(p, g, β, r, s, x):

    #Check if r is in our chosen domain 1 < r < p-1
    if not r >= 1 and r <= p-1: 
        return False
    
    #Compute t = β^r * r^s (mod p)
    t = (pow(β,r,p) * pow(r,s,p)) % p

    #Accept if and only if t = g^x (mod p)
    t_check = pow(g,x,p)
    return t == t_check

print("Signature is verified: " + str(verifySignature(p,g,β,r,s,x)))
